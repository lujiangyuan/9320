/*
	$Workfile:   DpRxEdid.c  $
	$Revision: 1.43 $
	$Date: 2013/06/14 02:38:01 $
*/
#define __DPRXEDID_C__

//******************************************************************************
// COPYRIGHT (C) STMicroelectronics 2010 All rights reserved.
// This document contains proprietary and confidential information of the
// STMicroelectronics Group. This document is not to be copied in whole or part.
// STMicroelectronics assumes no responsibility for the consequences of use of
// such information nor for any infringement of patents or other rights of third
// parties which may result from its use. No license is granted by implication
// or otherwise under any patent or patent rights of STMicroelectronics.
// STMicroelectronics products are not authorized for use as critical components
// in life support devices or systems without express written approval of
// STMicroelectronics.
//******************************************************************************

//==============================================================================
//
// MODULE:      DpRxEdid.c
//
//******************************************************************************

//******************************************************************************
//  I N C L U D E    F I L E S
//******************************************************************************
#include "System\all.h"
#include <string.h>

#if (FEATURE_DISPLAY_PORT == ENABLE)

//******************************************************************************
//  D E F I N E S
//******************************************************************************

//#define _DEBUG_MSG
#ifdef _DEBUG_MSG
#define msg(x,y)		gm_Print(x,y)
#else
#define msg(x,y)
#endif


#ifdef ST_4K2K_93xx_BOARD
#define DP_EDID_LOCATION		DP_EDID_FROM_CODE 
#endif


#define DP_EDID_ADDR_IN_NVRAM	NVRAM_DP_EDID_ADDR
//******************************************************************************
//  E X T E R N S
//******************************************************************************
extern U8 Internal_Edid[];
#if PATCH_OF_UNIQUE_EDID  
extern BOOL FAR  DP_GetLogicalPortBksv (U8 *Bksv_p8);
#endif

//******************************************************************************
//  G L O B AL
//******************************************************************************

//******************************************************************************
//  L O C A L S
//******************************************************************************
#if (DP_EDID_LOCATION == DP_EDID_FROM_CODE)
BYTE code DpEdidExample[]=
{
#if (PROJECT_SELECT == PROJ_4K2K)

	// NoBland_DP_3840x2160@30Hz	10Bit	20140510	ZDPD1420NB08	
	#if 0
	0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xDE,	0x51,	0x33,	0x01,
	0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25,
	0x0D,	0x50,	0x54,	0x21,	0x08,	0x14,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00,
	0x95,	0x00,	0xD1,	0xC0,	0x01,	0x01,	0xA3,	0x66,	0x00,	0xA0,	0xF0,	0x70,	0x1F,	0x80,	0x30,	0x20,
	0x35,	0x00,	0x6D,	0x55,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x4D,
	0x4E,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
	0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,	
	0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x66,
	
	0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13,
	0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x04,	0x74,	0x00,
	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,	0x8A,	0x00,	0x6D,	0x55,	0x21,	0x00,	0x00,	0x1E,	0x02,
	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x6D,	0x55,	0x21,	0x00,	0x00,
	0x1E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21,
	0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06,
	0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33,
	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xAC,
        #else
		
		0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x4D,	0x79,	0xDE,	0x07,	0xDE,	0x51,	0x33,	0x01, 
		0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25, 
		0x0D,	0x50,	0x54,	0x21,	0x08,	0x00,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00, 
		0x95,	0x00,	0xA9,	0x40,	0xA9,	0xC0,	0xA3,	0x66,	0x00,	0xA0,	0xF0,	0x70,	0x1F,	0x80,	0x30,	0x20, 
		0x35,	0x00,	0x6D,	0x55,	0x21,	0x00,	0x00,	0x1A,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40, 
		0x58,	0x2C,	0x45,	0x00,	0xE0,	0x0E,	0x11,	0x00,	0x00,	0x1E,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00, 
		0x1E,	0x30,	0x46,	0x8F,	0x33,	0x00,	0xAE,	0xFF,	0x10,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFC, 
		0x00,	0x53,	0x4B,	0x59,	0x38,	0x53,	0x32,	0x30,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x73, 
		
		0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13, 
		0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x04,	0x74,	0x00, 
		0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,	0x8A,	0x00,	0x6D,	0x55,	0x21,	0x00,	0x00,	0x1E,	0x02, 
		0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x6D,	0x55,	0x21,	0x00,	0x00, 
		0x1E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21, 
		0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06, 
		0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33, 
		0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xAC, 


	#endif
#elif(IS_PROJ_PD())


	// NoBland_DP_3840x2160@30Hz	10Bit	20140510	ZDPD1420NB08	
	0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xDE,	0x51,	0x33,	0x01,  
	0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25,  
	0x0D,	0x50,	0x54,	0xA5,	0x4B,	0x00,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00,  
	0x95,	0x00,	0x01,	0x01,	0x01,	0x01,	0xA3,	0x66,	0x00,	0xA0,	0xF0,	0x70,	0x1F,	0x80,	0x30,	0x20,  
	0x35,	0x00,	0x6D,	0xB6,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x50,  
	0x44,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,  
	0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,  
	0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0xE8, 
	
	0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13,  
	0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x04,	0x74,	0x00,  
	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,	0x8A,	0x00,	0x6D,	0x55,	0x21,	0x00,	0x00,	0x1E,	0x02,  
	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x6D,	0x55,	0x21,	0x00,	0x00,  
	0x1E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21,  
	0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06,  
	0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33,  
	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xAC,  


#else

#if (DEFAULT_PANEL == ST_2K2K_VEGA_2K2K || DEFAULT_PANEL == CMO_V562D1_L03)

#ifdef ST_4K2K_93xx_BOARD
	//1920x2160
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x4E, 0x8D, 0x68, 0x24, 0x4E, 0x61, 0xBC, 0x00,
	0x05, 0x16, 0x01, 0x04, 0xA5, 0x29, 0x2C, 0x78, 0xE2, 0x0D, 0xC9, 0xA0, 0x57, 0x47, 0x98, 0x27,
	0x12, 0x48, 0x4C, 0xA1, 0x08, 0x00, 0x81, 0x80, 0xA9, 0x40, 0xD1, 0x00, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x74, 0x80, 0x18, 0x71, 0x70, 0x5A, 0x80, 0x58, 0x2C,
	0x8A, 0x00, 0x99, 0xB6, 0x11, 0x00, 0x00, 0x1E, 0x04, 0x74, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80,
	0xB0, 0x58, 0x8A, 0x00, 0x99, 0xB6, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x1D,
	0x4B, 0x1F, 0x8C, 0x1E, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
	0x00, 0x41, 0x74, 0x68, 0x65, 0x6E, 0x61, 0x34, 0x4B, 0x32, 0x4B, 0x0A, 0x20, 0x20, 0x01, 0x02,
	0x02, 0x03, 0x00, 0x40, 0x23, 0x09, 0x7F, 0x07, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E
	
#else //Original
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x15, 0xC3, 0x43, 0x22, 0xAB, 0xC1, 0x98, 0x00,
	0x16, 0x15, 0x01, 0x04, 0xB5, 0x29, 0x2C, 0x78, 0xE2, 0x0D, 0xC9, 0xA0, 0x57, 0x47, 0x98, 0x27,
	0x12, 0x48, 0x4C, 0xA1, 0x08, 0x00, 0x81, 0x80, 0xA9, 0x40, 0xD1, 0x00, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x4E, 0x70, 0x00, 0xA0, 0x80, 0x70, 0x0D, 0x80, 0x30, 0x20,
	0x33, 0x00, 0x99, 0xB6, 0x11, 0x00, 0x00, 0x1A, 0x4E, 0x70, 0x00, 0xA0, 0x80, 0x70, 0x0D, 0x80,
	0x30, 0x20, 0x33, 0x00, 0x99, 0xB6, 0x11, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x1D,
	0x3D, 0x1F, 0x8C, 0x1D, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
	0x00, 0x52, 0x58, 0x38, 0x34, 0x30, 0x20, 0x41, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63,

	0x02, 0x03, 0x00, 0x40, 0x23, 0x09, 0x7F, 0x07, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E
#endif

  #elif (DEFAULT_PANEL == LG_WQXGA_LM300WQ5_SLA1) || (DEFAULT_PANEL == ST_WQXGA_VEGA_WQXGA)||(DEFAULT_PANEL == LG_WQXGA_LM300WQ6_SLA1)

		//NoBland DP 2560x1600@60Hz	//20140510		ZDMN1420NB08

		0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xE8,	0x51,	0x33,	0x01, 
		0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25, 
		0x0D,	0x50,	0x54,	0x21,	0x08,	0x14,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00, 
		0x95,	0x00,	0xD1,	0xC0,	0x01,	0x01,	0xE2,	0x68,	0x00,	0xA0,	0xA0,	0x40,	0x2E,	0x60,	0x30,	0x20, 
		0x36,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x4D, 
		0x4E,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44, 
		0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD, 		
		0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x23,
		
		0x02,	0x03,	0x1D,	0xF9,	0x50,	0x90,	0x05,	0x84,	0x83,	0x82,	0x07,	0x16,	0x81,	0x9F,	0x92,	0x93, 
		0x14,	0xA0,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x02,	0x3A,	0x80, 
		0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1E,	0x01, 
		0x1D,	0x80,	0x18,	0x71,	0x1C,	0x16,	0x20,	0x58,	0x2C,	0x25,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00, 
		0x9E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21, 
		0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06, 
		0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33, 
		0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x68, 
								

  #elif (DEFAULT_PANEL == LG_WQHD_LM270WQ1) || (DEFAULT_PANEL == ST_WQHD_VEGA_WQHD) 



		//Nobland DP 2560x1440@60Hz		//20140510		//ZDMN1420NB08
	0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xE8,	0x51,	0x33,	0x01,
	0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25,
	0x0D,	0x50,	0x54,	0x21,	0x08,	0x14,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00,
	0x95,	0x00,	0xD1,	0xC0,	0x01,	0x01,	0x56,	0x5E,	0x00,	0xA0,	0xA0,	0xA0,	0x29,	0x50,	0x30,	0x20,
	0x35,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x4D,
	0x4E,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
	0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
	0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x6F,
	
	0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13,
	0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x02,	0x3A,	0x80,
	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1E,	0x01,
	0x1D,	0x80,	0x18,	0x71,	0x1C,	0x16,	0x20,	0x58,	0x2C,	0x25,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,
	0x9E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21,
	0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06,
	0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33,
	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x70,



	#elif ((DEFAULT_PANEL == LG_1080P_LC320EUN)||(DEFAULT_PANEL == SAMSUNG_WXGA_LTI260AP01)\
  	||(DEFAULT_PANEL == SAMSUNG_1080P_LTI460HM03)||(DEFAULT_PANEL == CMO_WSXGA_M220Z1_L09)||(DEFAULT_PANEL == CMO_WSXGA_M220Z1_L01)\
  	||(DEFAULT_PANEL == LG_1080P_LD420WUB_8BIT)||(DEFAULT_PANEL == LG_1080P_LD420WUB_10BIT)||(DEFAULT_PANEL == LG_1080P_LD470WUB_10BIT)\
	||(DEFAULT_PANEL == LG_1080P_LD420WUB_8BIT)||(DEFAULT_PANEL == AUO_1080P_T550HVN01V9_8BIT))

	#if(IS_PROJ_PD())
	//ZDT DP 1920x1080@60Hz 		//20140510 ZDPD1420NB08
	0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xDE,	0x51,	0x33,	0x01,
	0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1E,	0xC5,	0xAE,	0x4F,	0x34,	0xB1,	0x26,
	0x0E,	0x50,	0x54,	0x21,	0x08,	0x14,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00,
	0x95,	0x00,	0xD1,	0xC0,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
	0x45,	0x00,	0xE0,	0x0E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x50,
	0x44,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
	0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
	0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0xF7,
	
	0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13,
	0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x07,	0x07,	0x83,	0x01,	0x00,	0x00,	0x02,	0x3A,	0x80,
	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1E,	0x01,
	0x1D,	0x80,	0x18,	0x71,	0x1C,	0x16,	0x20,	0x58,	0x2C,	0x25,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,
	0x9E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21,
	0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06,
	0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33,
	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x88,

	#else
	//ZDT DP 1920x1080@60Hz 	  //20140510 ZDMN1420NB08
	0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xDE,	0x51,	0x33,	0x01,
	0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25,
	0x0D,	0x50,	0x54,	0x21,	0x08,	0x10,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00,
	0x95,	0x00,	0xD1,	0xC0,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
	0x45,	0x00,	0xE0,	0x0E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x4D,
	0x4E,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
	0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
	0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0xC4,
	
	0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13,
	0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x02,	0x3A,	0x80,
	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1E,	0x01,
	0x1D,	0x80,	0x18,	0x71,	0x1C,	0x16,	0x20,	0x58,	0x2C,	0x25,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,
	0x9E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21,
	0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06,
	0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33,
	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x70,

	#endif

  #elif (DEFAULT_PANEL == CMO_1080P_M236H5_L02_120) || (DEFAULT_PANEL == LG_1080P_LM270WF3_120)
  // 1080P @ 120Hz
  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x1D, 0xA3, 0x01, 0x69, 0x65, 0x00, 0x00, 0x00, 
  0x2A, 0x11, 0x01, 0x04, 0x08, 0x25, 0x16, 0x78, 0x0A, 0x0D, 0xC9, 0xA0, 0x57, 0x47, 0x98, 0x27, 
  0x12, 0x48, 0x4C, 0xEF, 0xEF, 0x00, 0xD1, 0xFC, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x74, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 
  0x45, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x5E, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 
  0x10, 0x3E, 0x96, 0x00, 0xE8, 0x12, 0x11, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x48, 
  0x44, 0x4D, 0x49, 0x20, 0x54, 0x56, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD, 
  0x00, 0x31, 0x4B, 0x0F, 0x4B, 0x0F, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x2D, 
  0x02, 0x03, 0x00, 0xB1, 0x4B, 0x90, 0x1F, 0x01, 0x02, 0x03, 0x04, 0x05, 0x07, 0x09, 0x13, 0x14, 
  0x23, 0x0F, 0x7F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52
  #elif (DEFAULT_PANEL == LG_1080P_LM230WF8_TLA1) || (DEFAULT_PANEL == CMO_1080P_M236H5_L02_60)\
  || (DEFAULT_PANEL == ST_1080P_VEGA_1080P)||(DEFAULT_PANEL == LG_1080P_LC320EUN)
  
  //ZDT DP 1920x1080@60Hz		//20140510 ZDMN1420NB08
  0x00,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0x00,   0x68,   0x94,   0xDE,   0x07,   0xDE,   0x51,   0x33,   0x01,
  0x14,   0x18,   0x01,   0x04,   0xB5,   0x34,   0x20,   0x78,   0x3A,   0x1D,   0xF5,   0xAE,   0x4F,   0x35,   0xB3,   0x25,
  0x0D,   0x50,   0x54,   0x21,   0x08,   0x10,   0x81,   0x80,   0xA9,   0x40,   0xD1,   0x00,   0x71,   0x4F,   0xB3,   0x00,
  0x95,   0x00,   0xD1,   0xC0,   0x01,   0x01,   0x02,   0x3A,   0x80,   0x18,   0x71,   0x38,   0x2D,   0x40,   0x58,   0x2C,
  0x45,   0x00,   0xE0,   0x0E,   0x11,   0x00,   0x00,   0x1E,   0x00,   0x00,   0x00,   0xFF,   0x00,   0x5A,   0x44,   0x4D,
  0x4E,   0x31,   0x34,   0x32,   0x30,   0x4E,   0x42,   0x30,   0x38,   0x0A,   0x00,   0x00,   0x00,   0xFC,   0x00,   0x44,
  0x50,   0x31,   0x2E,   0x32,   0x0A,   0x20,   0x20,   0x20,   0x20,   0x20,   0x20,   0x20,   0x00,   0x00,   0x00,   0xFD,
  0x00,   0x38,   0x4C,   0x1E,   0x51,   0x1F,   0x00,   0x0A,   0x20,   0x20,   0x20,   0x20,   0x20,   0x20,   0x01,   0xC4,
  
  0x02,   0x03,   0x1D,   0xF1,   0x50,   0x90,   0x05,   0x04,   0x03,   0x02,   0x07,   0x16,   0x01,   0x1F,   0x12,   0x13,
  0x14,   0x20,   0x15,   0x11,   0x06,   0x23,   0x09,   0x1F,   0x07,   0x83,   0x01,   0x00,   0x00,   0x02,   0x3A,   0x80,
  0x18,   0x71,   0x38,   0x2D,   0x40,   0x58,   0x2C,   0x45,   0x00,   0x06,   0x44,   0x21,   0x00,   0x00,   0x1E,   0x01,
  0x1D,   0x80,   0x18,   0x71,   0x1C,   0x16,   0x20,   0x58,   0x2C,   0x25,   0x00,   0x06,   0x44,   0x21,   0x00,   0x00,
  0x9E,   0x01,   0x1D,   0x00,   0x72,   0x51,   0xD0,   0x1E,   0x20,   0x6E,   0x28,   0x55,   0x00,   0x06,   0x44,   0x21,
  0x00,   0x00,   0x1E,   0x8C,   0x0A,   0xD0,   0x8A,   0x20,   0xE0,   0x2D,   0x10,   0x10,   0x3E,   0x96,   0x00,   0x06,
  0x44,   0x21,   0x00,   0x00,   0x18,   0x66,   0x21,   0x56,   0xAA,   0x51,   0x00,   0x1E,   0x30,   0x46,   0x8F,   0x33,
  0x00,   0x06,   0x44,   0x21,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x70,



  #elif (DEFAULT_PANEL == SAMSUNG_WUXGA_LTM240W1_L01) || (DEFAULT_PANEL == LG_WUXGA_LM240WU9_SLA1) ||\
  	(DEFAULT_PANEL == LG_WUXGA_LM240WU4_SLB1) || (DEFAULT_PANEL == LG_WUXGA_LM260WU2_SLA1)\
  	|| (DEFAULT_PANEL == LPL_WUXGA_LM240WU5)

	//ZDT Nobland DP 1920x1200@60Hz 		//20140510 ZDMN1420NB08
	0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xDE,	0x51,	0x33,	0x01,
	0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25,
	0x0D,	0x50,	0x54,	0x21,	0x08,	0x14,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00,
	0x95,	0x00,	0xD1,	0xC0,	0x01,	0x01,	0x28,	0x3C,	0x80,	0xA0,	0x70,	0xB0,	0x23,	0x40,	0x30,	0x20,
	0x36,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x4D,
	0x4E,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
	0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
	0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x7E,
	
	0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13,
	0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x02,	0x3A,	0x80,
	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1E,	0x01,
	0x1D,	0x80,	0x18,	0x71,	0x1C,	0x16,	0x20,	0x58,	0x2C,	0x25,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,
	0x9E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21,
	0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06,
	0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33,
	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x70,


#elif (DEFAULT_PANEL == LG_WHD_LM290WW1_SSA1)
  //DP NoBland 2560x1080@60Hz		//20140510			ZDMN1420NB08
  0x00,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0xFF,   0x00,   0x68,   0x94,   0xDE,   0x07,   0xDE,   0x51,   0x33,   0x01, 
  0x14,   0x18,   0x01,   0x04,   0xB5,   0x34,   0x20,   0x78,   0x3A,   0x1E,   0xC5,   0xAE,   0x4F,   0x34,   0xB1,   0x26, 
  0x0E,   0x50,   0x54,   0x21,   0x08,   0x14,   0x81,   0x80,   0xA9,   0x40,   0xD1,   0x00,   0x71,   0x4F,   0xB3,   0x00, 
  0x95,   0x00,   0xD1,   0xC0,   0x01,   0x01,   0x7E,   0x48,   0x00,   0xE0,   0xA0,   0x38,   0x1F,   0x40,   0x40,   0x40, 
  0x3A,   0x00,   0x06,   0x44,   0x21,   0x00,   0x00,   0x1A,   0x00,   0x00,   0x00,   0xFF,   0x00,   0x5A,   0x44,   0x4D, 
  0x4E,   0x31,   0x34,   0x32,   0x30,   0x4E,   0x42,   0x30,   0x38,   0x0A,   0x00,   0x00,   0x00,   0xFC,   0x00,   0x44, 
  0x50,   0x31,   0x2E,   0x32,   0x0A,   0x20,   0x20,   0x20,   0x20,   0x20,   0x20,   0x20,   0x00,   0x00,   0x00,   0xFD, 
  0x00,   0x38,   0x4C,   0x1E,   0x51,   0x1F,   0x00,   0x0A,   0x20,   0x20,   0x20,   0x20,   0x20,   0x20,   0x01,   0xA4, 
  
  0x02,   0x03,   0x1D,   0xF1,   0x50,   0x90,   0x05,   0x04,   0x03,   0x02,   0x07,   0x16,   0x01,   0x1F,   0x12,   0x13, 
  0x14,   0x20,   0x15,   0x11,   0x06,   0x23,   0x09,   0x1F,   0x07,   0x83,   0x01,   0x00,   0x00,   0x02,   0x3A,   0x80, 
  0x18,   0x71,   0x38,   0x2D,   0x40,   0x58,   0x2C,   0x45,   0x00,   0x06,   0x44,   0x21,   0x00,   0x00,   0x1E,   0x01, 
  0x1D,   0x80,   0x18,   0x71,   0x1C,   0x16,   0x20,   0x58,   0x2C,   0x25,   0x00,   0x06,   0x44,   0x21,   0x00,   0x00, 
  0x9E,   0x01,   0x1D,   0x00,   0x72,   0x51,   0xD0,   0x1E,   0x20,   0x6E,   0x28,   0x55,   0x00,   0x06,   0x44,   0x21, 
  0x00,   0x00,   0x1E,   0x8C,   0x0A,   0xD0,   0x8A,   0x20,   0xE0,   0x2D,   0x10,   0x10,   0x3E,   0x96,   0x00,   0x06, 
  0x44,   0x21,   0x00,   0x00,   0x18,   0x66,   0x21,   0x56,   0xAA,   0x51,   0x00,   0x1E,   0x30,   0x46,   0x8F,   0x33, 
  0x00,   0x06,   0x44,   0x21,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x70, 

#else 
//ZDT DP 1920x1080@60Hz 	  //20140510 ZDMN1420NB08
0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xDE,	0x51,	0x33,	0x01,
0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25,
0x0D,	0x50,	0x54,	0x21,	0x08,	0x10,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00,
0x95,	0x00,	0xD1,	0xC0,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
0x45,	0x00,	0xE0,	0x0E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x4D,
0x4E,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0xC4,

0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13,
0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x02,	0x3A,	0x80,
0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1E,	0x01,
0x1D,	0x80,	0x18,	0x71,	0x1C,	0x16,	0x20,	0x58,	0x2C,	0x25,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,
0x9E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21,
0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06,
0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33,
0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x70,

#endif //DEFAULT_PANEL==
#endif // PROJECT_SELECT
};
#else
BYTE code DpEdidExample[]=
{
	//ZDT DP 1920x1080@60Hz 	  //20140510 ZDMN1420NB08
	0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x68,	0x94,	0xDE,	0x07,	0xDE,	0x51,	0x33,	0x01,
	0x14,	0x18,	0x01,	0x04,	0xB5,	0x34,	0x20,	0x78,	0x3A,	0x1D,	0xF5,	0xAE,	0x4F,	0x35,	0xB3,	0x25,
	0x0D,	0x50,	0x54,	0x21,	0x08,	0x10,	0x81,	0x80,	0xA9,	0x40,	0xD1,	0x00,	0x71,	0x4F,	0xB3,	0x00,
	0x95,	0x00,	0xD1,	0xC0,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
	0x45,	0x00,	0xE0,	0x0E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x5A,	0x44,	0x4D,
	0x4E,	0x31,	0x34,	0x32,	0x30,	0x4E,	0x42,	0x30,	0x38,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
	0x50,	0x31,	0x2E,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
	0x00,	0x38,	0x4C,	0x1E,	0x51,	0x1F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0xC4,
	
	0x02,	0x03,	0x1D,	0xF1,	0x50,	0x90,	0x05,	0x04,	0x03,	0x02,	0x07,	0x16,	0x01,	0x1F,	0x12,	0x13,
	0x14,	0x20,	0x15,	0x11,	0x06,	0x23,	0x09,	0x1F,	0x07,	0x83,	0x01,	0x00,	0x00,	0x02,	0x3A,	0x80,
	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,	0x45,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x1E,	0x01,
	0x1D,	0x80,	0x18,	0x71,	0x1C,	0x16,	0x20,	0x58,	0x2C,	0x25,	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,
	0x9E,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,	0x55,	0x00,	0x06,	0x44,	0x21,
	0x00,	0x00,	0x1E,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0x06,
	0x44,	0x21,	0x00,	0x00,	0x18,	0x66,	0x21,	0x56,	0xAA,	0x51,	0x00,	0x1E,	0x30,	0x46,	0x8F,	0x33,
	0x00,	0x06,	0x44,	0x21,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x70,

};
#endif //(DP_EDID_LOCATION == DP_EDID_FROM_CODE)
BYTE DpRxEDIDBuffer[EDID_BUFFER_SIZE];
static DprxVirtualEdid_t DpRxVirtualEdid[AUX_CH_END];
//static BYTE gB_AuxTransactionSize[AUX_CH_END]={AUX_TRANSACTION_SIZE,AUX_TRANSACTION_SIZE};
//static BYTE gB_AuxRx_EdidWrOffsetSize=1;
//******************************************************************************
//
//  C O D E
//
//******************************************************************************
//******************************************************************************
// FUNCTION:   static void DpRxLoadEdid2Buf(void)
// USAGE:	   Load DpRx EDID blocks to DpRxEDIDBuffer
// INPUT:	   None
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
#if (FEATURE_DP_HUB == ENABLE)
#define DP_EDID_ADDR_IN_VEGA 0
extern gmt_RET_STAT  NVRam_EdidReadBuffer(WORD W_RegAddr, BYTE *Bp_Buf, WORD W_Length);

BOOL IsDpTxReady(void)
{
#if (DP_EDID_LOCATION == DP_EDID_FROM_NVRAM)
	BYTE			  DpTxStatus				  = 0x3E;	
	WORD           Data						  = 0;	
	BOOL 		  HostStatus				  = FALSE;		
	U16            Timer_32					  = (U16)gm_GetSystemTime();

	// Have Vega pass A0 device id over AUX Chan
	gm_2WireWriteAddrBuffer (0xE6, (BYTE far *) &DpTxStatus, 1, (BYTE far *)&DpTxStatus, 0);

	// Delay for previous host interface transaction execution
	gm_Delay10ms(3);   

	while(ABS(Timer_32,(U16)gm_GetSystemTime()) < 1000 )
	{
		gm_2WireReadAddrBuffer (0xE6, (BYTE far *) &DpTxStatus, 1, (BYTE far *)&Data, 2);	

		Data = Data >> 8;

		if(Data & BIT4)
		{
			HostStatus = TRUE;
			break;
		}
	}
	gm_Print("**DpTx Status**=%x",Data);

	if(HostStatus == TRUE)
	{
		return TRUE;
	}
	else
	{
		return FALSE;	
	}
#else
   return FALSE;
#endif
}
#endif
void DpRxLoadEdid2Buf(void)
{
#if (DP_EDID_LOCATION == DP_EDID_FROM_NVRAM)
   #if (FEATURE_DP_HUB == ENABLE)
   BYTE           SetDeviceIdAddress            = 0x08;
   WORD           DeviceIdPassThrough           = 0xA004;

   // Have Vega pass A0 device id over AUX Chan
   gm_2WireWriteAddrBuffer (0xE6, (BYTE far *) &SetDeviceIdAddress, 1, (BYTE far *)&DeviceIdPassThrough, sizeof(DeviceIdPassThrough));
   // Delay for previous host interface transaction execution
   gm_Delay10ms(3);

   NVRam_EdidReadBuffer(DP_EDID_ADDR_IN_VEGA, DpRxEDIDBuffer, EDID_BUFFER_SIZE);
   #else
   NVRam_ReadBuffer(DP_EDID_ADDR_IN_NVRAM, DpRxEDIDBuffer, EDID_BUFFER_SIZE);
   #endif
#elif (DP_EDID_LOCATION == DP_EDID_FROM_CODE)
	#ifdef ST_4K2K_93xx_BOARD
		//UserPrefCaptureM=CAPTURE_MODE_FULL;
      #if 1
      if (GetChipID_4K2K()==CHIPID_4K2K_R)
      {
         if(UserPrefDPSWitch == DP_Input_11)
         {
            _fmemcpy((BYTE *)DpRxEDIDBuffer, DpEdid_4Kx2K_SST, EDID_BUFFER_SIZE);
            msg("Load EDID from Code SST", 0);
         }
         else
         {
            _fmemcpy((BYTE *)DpRxEDIDBuffer, DpEdid_4Kx2K_MST_R, EDID_BUFFER_SIZE);
            msg("Load EDID from Code MST_R", 0);
         }
      }
      else if(GetChipID_4K2K()==CHIPID_4K2K_L)
      {
         _fmemcpy((BYTE *)DpRxEDIDBuffer, DpEdid_4Kx2K_MST_L, EDID_BUFFER_SIZE);
         msg("Load EDID from Code MST_L", 0);
      }
      #else
		
		if(UserPrefDPSWitch == DP_Input_11)
		{
			_fmemcpy((BYTE *)DpRxEDIDBuffer, DpEdid_4Kx2K_SST, EDID_BUFFER_SIZE);
			msg("Load EDID from Code SST", 0);
		}
		else
		{
		   if (GetChipID_4K2K()==CHIPID_4K2K_R)
		   {
			   _fmemcpy((BYTE *)DpRxEDIDBuffer, DpEdid_4Kx2K_MST_R, EDID_BUFFER_SIZE);
			   msg("Load EDID from Code MST_R", 0);
   	   }
			else if(GetChipID_4K2K()==CHIPID_4K2K_L)
			{
			   _fmemcpy((BYTE *)DpRxEDIDBuffer, DpEdid_4Kx2K_MST_L, EDID_BUFFER_SIZE);
			   msg("Load EDID from Code MST_L", 0);
		   }
		}
		#endif
	#else // Standard 
   _fmemcpy((BYTE *)DpRxEDIDBuffer, DpEdidExample, EDID_BUFFER_SIZE);
	#endif //ST_4K2K_93xx_BOARD
#endif
}

//******************************************************************************
// FUNCTION:   void DpRxLoadEdid2Buf(void)
// USAGE:	   Load DpRx EDID buffer to Lpm virtualization EDID Buffer
// INPUT:	   None
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
/*
void DpRxLoadEdid2LpmBuf(void)
{
#define LPM_DP1_EDID_BUF_START				0xBD00
#define LPM_DP2_EDID_BUF_START				0xBC00

#if (FEATURE_LOW_POWER_MONITOR == ENABLE)
   //Load DP EDIDs to LPM for virtual EDID reply in LPM mode
   gm_LoadSRAMBlockEx(gmd_TAB_LPM, gmd_OCM_POLLING_MODE, gmd_SAFE_MODE,
                      (WORD far*)DpRxEDIDBuffer, LPM_DP2_EDID_BUF_START, EDID_BUFFER_SIZE);
   gm_LoadSRAMBlockEx(gmd_TAB_LPM, gmd_OCM_POLLING_MODE, gmd_SAFE_MODE,
                      (WORD far*)DpRxEDIDBuffer, LPM_DP1_EDID_BUF_START, EDID_BUFFER_SIZE);
#endif
}
*/

//******************************************************************************
// FUNCTION:   static void DpRxVirtualEdidInit(BYTE B_WrState, AUX_CH B_AuxCh)
// USAGE:      Initialize VirtualEDID R/W pointer and status
// INPUT:      B_WrState - Write status
//             B_AuxCh - indicate which Aux channel
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
static void DpRxVirtualEdidInit(BYTE B_WrState, AUX_CH B_AuxCh)
{
   DpRxVirtualEdid[B_AuxCh].W_ReadPointer = 0;
   DpRxVirtualEdid[B_AuxCh].W_WritePointer = 0;
   DpRxVirtualEdid[B_AuxCh].B_WrState = B_WrState;
}



//******************************************************************************
// FUNCTION:   void DpRxEdidHandlerInit(void)
// USAGE:	   Initialize DpRxAuxEDIDhandler
// INPUT:	   None
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
void DpRxEdidHandlerInit(void)
{
   BYTE i;

   //DpRxLoadEdid2Buf();	//Do it before DpRxLoadEdid2LpmBuf()

   for (i=0;i<AUX_CH_END;i++)
   {

      DpRxVirtualEdidInit(WR_FREE, i);
      DpRxVirtualEdid[i].Ba_EDIDReadBuffer = (BYTE *)DpRxEDIDBuffer;
   }


}


//******************************************************************************
// FUNCTION:   static void AuxRxEdidRead(BYTE B_DevAddress, BYTE *Bp_Buffer,
//                                       WORD W_Length, AUX_CH B_AuxCh)
// USAGE:      Reading from the EDID buffer using ISR
// INPUT:      BYTE B_DevAddress - I2C address
//             BYTE* Bp_Buffer - pointer to read buffer
//             WORD W_Length - how many bytes should be read
//             B_AuxCh - indicate which Aux channel
// OUTPUT:
// GLOBALS:
// USED_REGS:  None
//******************************************************************************
static void AuxRxEdidRead(BYTE B_DevAddress, BYTE *Bp_Buffer, WORD W_Length, AUX_CH B_AuxCh)
{
   if (B_DevAddress == EDID_EEPROM_DEV_ADDR)
   {
      _fmemcpy((BYTE *)Bp_Buffer, (BYTE *)&DpRxVirtualEdid[B_AuxCh].Ba_EDIDReadBuffer[DpRxVirtualEdid[B_AuxCh].W_ReadPointer], W_Length);
      DpRxVirtualEdid[B_AuxCh].W_ReadPointer += (BYTE)W_Length;
   }
}





//******************************************************************************
// FUNCTION:   static void AuxRxEdidWrite(BYTE B_DevAddress, BYTE *Bp_Buffer,
//                                        WORD W_Length, AUX_CH B_AuxCh)
// USAGE:      Writing to the EEPROM using ISR (Write is not enabled now)
// INPUT:      BYTE W_DevAddress - I2C address
//             BYTE* Bp_Buffer - pointer to read buffer
//             WORD W_Length - how many bytes should be read
//             B_AuxCh - indicate which Aux channel
// OUTPUT:
// GLOBALS:
// USED_REGS:  None
//******************************************************************************
static void AuxRxEdidWrite(BYTE B_DevAddress, BYTE *Bp_Buffer, WORD W_Length, AUX_CH B_AuxCh)
{

   if ((W_Length != 0) && (DpRxVirtualEdid[B_AuxCh].B_WrState == WR_FREE))
   {   // for run two steps one time
      DpRxVirtualEdidInit(WR_ADDR1, B_AuxCh);
   }

   switch (DpRxVirtualEdid[B_AuxCh].B_WrState)
   {
      case WR_START:
         DpRxVirtualEdidInit(WR_ADDR1, B_AuxCh);
         break;

      case WR_ADDR1:
         /*      		if(gB_AuxRx_EdidWrOffsetSize == 1)
                  	{ */
         DpRxVirtualEdid[B_AuxCh].W_Offset = Bp_Buffer[0];

         if (W_Length > 1)
         {
            //#if DPRX_EDID_FLASH_WR_ENABLE
            //_fmemcpy(&DpRxVirtualEdid.Ba_EDIDWriteBuffer[DprxVirtualEdid.W_WritePointer], &Bp_Buffer[1], W_Length-1);
            //#endif
            DpRxVirtualEdid[B_AuxCh].W_WritePointer += (BYTE)(W_Length - 1);
         }
         DpRxVirtualEdid[B_AuxCh].B_WrState = WR_DATA;
         /*         	}
                  	else
                  	{
                   		if(W_Length > 1)
                     	{
                      		DpRxVirtualEdid[B_AuxCh].W_Offset = (Bp_Buffer[0] << 8) || Bp_Buffer[1];
                      	   	//#if DPRX_EDID_FLASH_WR_ENABLE
                        		//_fmemcpy(&DpRxVirtualEdid.Ba_EDIDWriteBuffer[DpRxVirtualEdid.W_WritePointer], &Bp_Buffer[2], W_Length-2);
                      	   	//#endif
                        		DpRxVirtualEdid[B_AuxCh].W_WritePointer += (BYTE)(W_Length - 2);
                        		DpRxVirtualEdid[B_AuxCh].B_WrState = WR_DATA;
                     	}
                     	else
                     	{
                      		DpRxVirtualEdid[B_AuxCh].W_Offset = (Bp_Buffer[0] << 8);
                        		DpRxVirtualEdid[B_AuxCh].B_WrState = WR_ADDR2;
                     	}
                  	} */
         DpRxVirtualEdid[B_AuxCh].W_ReadPointer = Bp_Buffer[0];
         break;
         /*
         		case WR_ADDR2:
               		DpRxVirtualEdid[B_AuxCh].W_Offset |= Bp_Buffer[1];
               		//#if DPRX_EDID_FLASH_WR_ENABLE
                  	//_fmemcpy(&DpRxVirtualEdid.Ba_EDIDWriteBuffer[DpRxVirtualEdid.W_WritePointer], &Bp_Buffer[1], W_Length-1);
               		//#endif
                  	DpRxVirtualEdid[B_AuxCh].W_WritePointer += W_Length - 1;
                  	DpRxVirtualEdid[B_AuxCh].B_WrState = WR_DATA;
         		break;
         */
      case WR_DATA:
         //#if DPRX_EDID_FLASH_WR_ENABLE
         //_fmemcpy(&DpRxVirtualEdid.Ba_EDIDWriteBuffer[DpRxVirtualEdid.W_WritePointer], Bp_Buffer, W_Length);
         //#endif
         DpRxVirtualEdid[B_AuxCh].W_WritePointer += W_Length;
         break;

      case WR_STOP:
         //#if DPRX_EDID_FLASH_WR_ENABLE
         //if(gB_AuxRx_EdidWrProtect == AUX_EDID_WRITE_UNLOCK)
         //{
         //	_fmemcpy(&DpRxVirtualEdid.Ba_EDIDReadBuffer[DpRxVirtualEdid.W_Offset], DpRxVirtualEdid.Ba_EDIDWriteBuffer, DpRxVirtualEdid.W_WritePointer);
         //	DpRxVirtualEdidWrite();
         //}
         //#endif
         DpRxVirtualEdidInit(WR_FREE, B_AuxCh);
         break;

      default:
         DpRxVirtualEdid[B_AuxCh].B_WrState = WR_FREE;
         UNUSED_VAR(B_DevAddress);//only for pressing warming message
         break;
   }
}




#if (AUXLLI2C_TYPE==AUXLLI2C_FROM_IROM)
//******************************************************************************
// FUNCTION:   static void AuxRxEdidReadHandler(BYTE B_Addr, BYTE B_Len,
//                                       BYTE B_IsStop, AUX_CH B_AuxCh)
// USAGE:      Handle Aux EDID read transactions
// INPUT:      B_Addr - I2C device address
//             B_Len - how many byte to be read
//             B_IsStop - Is Stop or MOT
//             B_AuxCh - indicate which Aux channel
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
static void AuxRxEdidReadHandler(BYTE B_Addr, BYTE B_Len, BYTE B_IsStop, AUX_CH B_AuxCh)
{
   BYTE B_DataBuff[AUX_MAX_BYTES_IN_CHUNK];
   DpRxVirtualEdid[B_AuxCh].B_WrState = WR_FREE;

   if (B_Len == 0)
   {
      gm_DpRxAuxSetReplyData(NULL_PTR,0, B_AuxCh);
      gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);
      if (B_IsStop)
      {
         DpRxVirtualEdid[B_AuxCh].W_ReadPointer = 0;
      }
   }
   else
   {
      if (B_Len > AUX_TRANSACTION_SIZE)
         B_Len = AUX_TRANSACTION_SIZE;

      AuxRxEdidRead(B_Addr, B_DataBuff, B_Len, B_AuxCh);
      gm_DpRxAuxSetReplyData(B_DataBuff,B_Len, B_AuxCh);
      gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);

   }

}



//******************************************************************************
// FUNCTION:   static void AuxRxEdidWriteHandler(BYTE B_Addr, BYTE B_Len,
//                                               BYTE B_IsStop, AUX_CH B_AuxCh)
// USAGE:      Handle Aux EDID write transactions
// INPUT:      B_Addr - I2C device address
//             B_Len - how many byte to be written
//             B_IsStop - Is Stop or MOT
//             B_AuxCh - indicate which Aux channel
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
static void AuxRxEdidWriteHandler(BYTE B_Addr, BYTE B_Len, BYTE B_IsStop, AUX_CH B_AuxCh)
{
   BYTE B_DataBuff[AUX_MAX_BYTES_IN_CHUNK];

   if (B_Len != 0)
   {
      gm_DpRxAuxGetChunkData(B_DataBuff, B_Len, B_AuxCh);

      AuxRxEdidWrite(B_Addr, B_DataBuff, B_Len, B_AuxCh);
      gm_DpRxAuxSetReplyData(NULL_PTR,0, B_AuxCh);
      gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);

      if (B_IsStop)
      {
         DpRxVirtualEdid[B_AuxCh].B_WrState = WR_STOP;
         AuxRxEdidWrite(B_Addr, NULL_PTR, 0, B_AuxCh);
      }
   }
   else
   {
      if (B_IsStop)
      {
         DpRxVirtualEdid[B_AuxCh].B_WrState = WR_STOP;
      }
      else
      {
         DpRxVirtualEdid[B_AuxCh].B_WrState = WR_START;
      }
      AuxRxEdidWrite(B_Addr, NULL_PTR, 0, B_AuxCh);
      gm_DpRxAuxSetReplyData(NULL_PTR,0, B_AuxCh);
      gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);
   }

}



//******************************************************************************
// FUNCTION:   BOOL DpRxEdidHandler(DWORD DW_Addr, BYTE B_Req, BYTE B_Len,
//                                  AUX_CH B_AuxCh)
// USAGE:      Handle Aux EDID read/write transactions
// INPUT:      B_Addr - I2C device address
//             B_Len - how many byte to be read/write
//             B_Req - Request command
//             B_AuxCh - indicate which Aux channel
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
BOOL DpRxEdidHandler(DWORD DW_Addr, BYTE B_Req, BYTE B_Len, AUX_CH B_AuxCh)
{
   BYTE B_IsStop;
   BYTE B_Addr = (BYTE)DW_Addr;

   B_Addr <<= 1;
   B_IsStop = (B_Req & AUX_REQUEST_MOT) ? FALSE : TRUE;


   if ((B_Req & AUX_REQUEST_COMMAND_MASK) == AUX_REQUEST_I2C_READ)
   {
      AuxRxEdidReadHandler(B_Addr, B_Len, B_IsStop, B_AuxCh);
   }
   else if ((B_Req & AUX_REQUEST_COMMAND_MASK) == AUX_REQUEST_I2C_WRITE)
   {
      AuxRxEdidWriteHandler(B_Addr, B_Len, B_IsStop, B_AuxCh);
   }
   else
   {
      //Status update: it should not happen in a normal way of events
      gm_DpRxAuxSetReplyData(NULL_PTR,0, B_AuxCh);
      gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);
   }
   return FALSE;
}
#elif (AUXLLI2C_TYPE==AUXLLI2C_FROM_LIB)
//******************************************************************************
// FUNCTION:   static void AuxRxEdidReadHandler(BYTE B_Addr, BYTE B_Len,
//                               BYTE B_IsStop, AUX_CH B_AuxCh,BYTE *B_DataBuff)
// USAGE:      Handle Aux EDID read transactions
// INPUT:      B_Addr - I2C device address
//             B_Len - how many byte to be read
//             B_IsStop - Is Stop or MOT
//             B_AuxCh - indicate which Aux channel
//             *B_DataBuff - Point of Data buffer
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
static void AuxRxEdidReadHandler(BYTE B_Addr, BYTE B_Len, BYTE B_IsStop, AUX_CH B_AuxCh,BYTE *B_DataBuff)
{
   //BYTE B_DataBuff[AUX_MAX_BYTES_IN_CHUNK];
   DpRxVirtualEdid[B_AuxCh].B_WrState = WR_FREE;

   if (B_Len == 0)
   {
      //gm_DpRxAuxSetReplyData(NULL_PTR,0, B_AuxCh);
      //gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);
      if (B_IsStop)
      {
         DpRxVirtualEdid[B_AuxCh].W_ReadPointer = 0;
      }
   }
   else
   {
      if (B_Len > AUX_TRANSACTION_SIZE)
         B_Len = AUX_TRANSACTION_SIZE;

      AuxRxEdidRead(B_Addr, B_DataBuff, B_Len, B_AuxCh);
      //gm_DpRxAuxSetReplyData(B_DataBuff,B_Len, B_AuxCh);
      //gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);

   }

}



//******************************************************************************
// FUNCTION:   static void AuxRxEdidWriteHandler(BYTE B_Addr, BYTE B_Len,
//                              BYTE B_IsStop, AUX_CH B_AuxCh, BYTE *B_DataBuff)
// USAGE:      Handle Aux EDID write transactions
// INPUT:      B_Addr - I2C device address
//             B_Len - how many byte to be written
//             B_IsStop - Is Stop or MOT
//             B_AuxCh - indicate which Aux channel
//             *B_DataBuff - Point of Data buffer
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
static void AuxRxEdidWriteHandler(BYTE B_Addr, BYTE B_Len, BYTE B_IsStop, AUX_CH B_AuxCh, BYTE *B_DataBuff)
{
   //BYTE B_DataBuff[AUX_MAX_BYTES_IN_CHUNK];
   if (B_Len != 0)
   {
      //gm_DpRxAuxGetChunkData(B_DataBuff, B_Len, B_AuxCh);
      AuxRxEdidWrite(B_Addr, B_DataBuff, B_Len, B_AuxCh);
      //gm_DpRxAuxSetReplyData(NULL_PTR,0, B_AuxCh);
      //gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);

      if (B_IsStop)
      {
         DpRxVirtualEdid[B_AuxCh].B_WrState = WR_STOP;
         AuxRxEdidWrite(B_Addr, NULL_PTR, 0, B_AuxCh);
      }
   }
   else
   {
      if (B_IsStop)
      {
         DpRxVirtualEdid[B_AuxCh].B_WrState = WR_STOP;
      }
      else
      {
         DpRxVirtualEdid[B_AuxCh].B_WrState = WR_START;
      }
      AuxRxEdidWrite(B_Addr, NULL_PTR, 0, B_AuxCh);
      //gm_DpRxAuxSetReplyData(NULL_PTR,0, B_AuxCh);
      //gm_DpRxAuxSetReplyCmd(AUX_REPLY_CMD_AUX_ACK, B_AuxCh);
   }

}


//******************************************************************************
// FUNCTION:   BOOL DpRxEdidHandler(WORD W_Addr, BOOL B_IsRead, BYTE *BufPtr,
//                                  WORD W_Len, BYTE B_Stop, AUX_CH B_AuxCh)
// USAGE:      Handle Aux EDID read/write transactions
// INPUT:      W_Addr - I2C device address
//             B_IsRead - Read/Write indication
//             *BufPtr  - Point of Data Buffer
//             W_Len - how many byte to be read/write
//             B_AuxCh - indicate which Aux channel
// OUTPUT:
// GLOBALS:
// USED_REGS:
//******************************************************************************
BOOL DpRxEdidHandler(WORD W_Addr, BOOL B_IsRead, BYTE *BufPtr, WORD W_Len, BYTE B_Stop, AUX_CH B_AuxCh)
{
   BYTE B_Addr = (BYTE)W_Addr;
   B_Addr <<= 1;

   if (B_Addr==0xA0)
   {
      if (B_IsRead == TRUE)
      {	//Read
          //For Dell780 PC IntelR4 Series Internal Chipset bootup screen can't display issue
          //If PC send 0x600 = 0x02 and still try to get EDID, set 0x600 =0x01 to avoid set timing unatble
	  *LINEAR_TO_FPTR_B(0x1F600)=0x01;//owen 121204 for Intel?4 Series graphics card
         AuxRxEdidReadHandler(B_Addr, (BYTE)W_Len, B_Stop, B_AuxCh, BufPtr);
      }
      else
      {	//Write
         AuxRxEdidWriteHandler(B_Addr, (BYTE)W_Len, B_Stop, B_AuxCh, BufPtr);
      }
      return TRUE;
   }
   return FALSE;
}
#endif

#if PATCH_OF_UNIQUE_EDID  
void PatchOfUniqueEDID(void)
{
	BYTE CheckSum = 0;
	WORD W_Counter = 0;
	U8 BksvBuffer[5]={0};

	DP_GetLogicalPortBksv (BksvBuffer);
/*	
	gm_Printf("BKSV Buff[0] = 0x%X",BksvBuffer[0] );
	gm_Printf("BKSV Buff[1] = 0x%X",BksvBuffer[1] );
	gm_Printf("BKSV Buff[2] = 0x%X",BksvBuffer[2] );
	gm_Printf("BKSV Buff[3] = 0x%X",BksvBuffer[3] );
	gm_Printf("BKSV Buff[4] = 0x%X",BksvBuffer[4] );
*/
	for (W_Counter = 0; W_Counter < 4; W_Counter++)
	{
		DpRxEDIDBuffer[0x0C+W_Counter] = BksvBuffer[W_Counter];
	}

	CheckSum = 0;
	for (W_Counter = 0; W_Counter < 127; W_Counter++)
	{
		CheckSum += DpRxEDIDBuffer[W_Counter];
	}
	CheckSum = (0xFF - (BYTE)CheckSum)+1;
	//gm_Printf("New EDID Block Checksum = 0x%X",(BYTE)CheckSum );
	DpRxEDIDBuffer[0x7F] = (BYTE)CheckSum;		
}
#endif

#endif



